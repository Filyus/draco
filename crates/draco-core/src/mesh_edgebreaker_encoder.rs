// Edgebreaker connectivity bitstream layout (C++-compatible).
//
// All integers are Varints unless specified otherwise.
//
// 1) num_vertices (total encoded vertices)
// 2) num_faces
// 3) num_attribute_data (non-position attributes)
// 4) num_encoded_symbols
// 5) num_split_symbols (count of Split symbols)
// 6) topology_split_event_data (see EncodeSplitData below)
// 7) traversal_buffer (as produced by Draco traversal encoder):
//    - bit-encoded traversal symbols (size-prefixed)
//    - start_face_configurations (rANS-bit)
//    - attribute_seam_data (rANS-bit per attribute; not emitted by Rust yet)
//
// Split event encoding (from C++ EncodeSplitData):
//   - num_events (varint)
//   - For each event:
//     - delta(source_symbol_id) from last_source_symbol_id (varint)
//     - delta(source_symbol_id - split_symbol_id) (varint, always positive)
//   - All source_edge bits (1 bit each, direct bit-encoded; only if num_events > 0)

use std::collections::HashMap;
use crate::mesh::Mesh;
use crate::corner_table::CornerTable;
use crate::encoder_buffer::EncoderBuffer;
use crate::status::DracoError;
use crate::geometry_indices::{PointIndex, CornerIndex, FaceIndex, VertexIndex, INVALID_CORNER_INDEX};
use crate::mesh_edgebreaker_shared::{EdgebreakerSymbol, EdgeFaceName, TopologySplitEventData};
use crate::rans_bit_encoder::RAnsBitEncoder;

pub struct MeshEdgebreakerEncoder {
    visited_faces: Vec<bool>,
    visited_vertices: Vec<bool>,
    face_to_symbol_id: Vec<u32>,
    point_ids: Vec<PointIndex>,
    symbols: Vec<u32>,
    topology_split_event_data: Vec<TopologySplitEventData>,
    face_to_split_symbol_map: HashMap<usize, i32>,
    last_encoded_symbol_id: i32,

    // Traversal order for attribute encoding
    processed_connectivity_corners: Vec<CornerIndex>,
    init_face_connectivity_corners: Vec<CornerIndex>,

    // Sequence of vertices as they would be generated by the Decoder.
    // Stored per symbol (in Encoder order).
    symbol_to_encoder_corner: Vec<CornerIndex>,

    // Boundary tracking
    init_face_configurations: Vec<bool>,
    encoded_faces: Vec<FaceIndex>,
}

impl MeshEdgebreakerEncoder {
    pub fn new(num_faces: usize, num_vertices: usize) -> Self {
        Self {
            visited_faces: vec![false; num_faces],
            visited_vertices: vec![false; num_vertices],
            face_to_symbol_id: vec![u32::MAX; num_faces],
            point_ids: Vec::new(),
            symbols: Vec::new(),
            topology_split_event_data: Vec::new(),
            face_to_split_symbol_map: HashMap::new(),
            last_encoded_symbol_id: -1,
            processed_connectivity_corners: Vec::new(),
            init_face_connectivity_corners: Vec::new(),
            symbol_to_encoder_corner: Vec::new(),
            init_face_configurations: Vec::new(),
            encoded_faces: Vec::new(),
        }
    }

    /// Find the starting corner for encoding a component.
    /// For boundary faces, returns the corner opposite to a boundary edge.
    /// This matches the C++ FindInitFaceConfiguration logic:
    /// - First check all 3 corners for boundary edges (no opposite)
    /// - Then check for boundary vertices (which would swing to a different face)
    /// Important: We must check ALL corners for boundary edges BEFORE checking
    /// for boundary vertices, to avoid swinging away from the current face prematurely.
    fn find_start_corner(&self, corner_table: &CornerTable, face_id: FaceIndex) -> CornerIndex {
        let first = corner_table.first_corner(face_id);
        
        // First pass: Check all corners for boundary edges
        let corners = [first, corner_table.next(first), corner_table.previous(first)];
        for &c in &corners {
            if corner_table.opposite(c) == INVALID_CORNER_INDEX {
                return c;
            }
        }
        
        // If no boundary edge found, return first corner (interior face)
        first
    }

    pub fn encode_connectivity(
        &mut self,
        mesh: &Mesh,
        corner_table: &CornerTable,
        out_buffer: &mut EncoderBuffer,
    ) -> Result<(Vec<PointIndex>, Vec<u32>), DracoError> {
        self.visited_faces = vec![false; mesh.num_faces()];
        self.visited_vertices = vec![false; mesh.num_points()];
        self.symbols.clear();
        self.topology_split_event_data.clear();
        self.face_to_split_symbol_map.clear();
        self.last_encoded_symbol_id = -1;
        self.init_face_configurations.clear();
        self.processed_connectivity_corners.clear();
        self.init_face_connectivity_corners.clear();
        self.symbol_to_encoder_corner.clear();
        self.encoded_faces.clear();

        self.point_ids.clear();

        // Traverse the surface starting from each unvisited corner (Draco C++ behavior).
        // For interior components, the init face is not represented by symbols; the
        // decoder reconstructs it from the start-face configuration stream.
        for c_id in 0..corner_table.num_corners() {
            let corner_index = CornerIndex(c_id as u32);
            let face_id = corner_table.face(corner_index);
            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                continue;
            }
            if self.visited_faces[face_id.0 as usize] {
                continue;
            }
            if corner_table.is_degenerated(face_id) {
                continue;
            }

            let start_corner = self.find_start_corner(corner_table, face_id);
            let interior_config = self.is_face_interior(corner_table, face_id);
            self.init_face_configurations.push(interior_config);

            if interior_config {
                // Mark all vertices of the init face as visited.
                let v0 = corner_table.vertex(start_corner);
                let v1 = corner_table.vertex(corner_table.next(start_corner));
                let v2 = corner_table.vertex(corner_table.previous(start_corner));
                self.visited_vertices[v0.0 as usize] = true;
                self.visited_vertices[v1.0 as usize] = true;
                self.visited_vertices[v2.0 as usize] = true;

                // Mark the init face as visited (it is reconstructed on decode).
                self.visited_faces[face_id.0 as usize] = true;

                // Store the init-face connectivity corner (processed after regular corners).
                let init_corner = corner_table.next(start_corner);
                self.init_face_connectivity_corners.push(init_corner);

                // Start compressing from the opposite face of the "next" corner.
                let opp_id = corner_table.opposite(init_corner);
                let opp_face_id = corner_table.face(opp_id);
                if opp_face_id != crate::geometry_indices::INVALID_FACE_INDEX
                    && !self.visited_faces[opp_face_id.0 as usize]
                {
                    self.encode_component(corner_table, opp_id)?;
                }
            } else {
                // Boundary configuration: start on the boundary.
                self.encode_component(corner_table, start_corner)?;
            }
        }

        // Write traversal decoder type (Standard = 0)
        out_buffer.encode_u8(0);

        // Write header (C++ format)
        let num_encoded_vertices = corner_table.num_vertices() - corner_table.num_isolated_vertices();
        let num_encoded_faces = corner_table.num_faces() - corner_table.num_degenerated_faces();
        out_buffer.encode_varint(num_encoded_vertices as u64);
        out_buffer.encode_varint(num_encoded_faces as u64);
        out_buffer.encode_u8(0); // num_attribute_data (we don't encode attribute seams yet)

        // Encode number of symbols
        out_buffer.encode_varint(self.symbols.len() as u64);

        // Encode number of split symbols.
        let num_split_symbols = self
            .symbols
            .iter()
            .filter(|&&s| s == EdgebreakerSymbol::Split as u32)
            .count();
        out_buffer.encode_varint(num_split_symbols as u64);

        // Sort split data by source symbol id
        self.topology_split_event_data.sort_by_key(|e| e.source_symbol_id);

        // Encode split event data
        self.encode_split_data(out_buffer)?;

        // Encode traversal buffer (C++ compatible): symbols + start faces.
        self.encode_traversal_buffer(mesh, out_buffer)?;

        // Generate attribute traversal order to match Draco C++:
        // DepthFirstTraverser over the encoder corner table, seeded by the
        // connectivity corners in decoder order.
        let (point_ids, data_to_corner_map) =
            self.generate_attribute_traversal(corner_table);
        self.point_ids = point_ids;

        Ok((self.point_ids.clone(), data_to_corner_map))
    }
    #[allow(dead_code)]    fn generate_point_ids(&mut self, mesh: &Mesh, _encoder_corner_table: &CornerTable) -> CornerTable {
        // For prediction schemes we need a CornerTable that matches the face
        // order produced by the connectivity decoder. The Edgebreaker
        // connectivity decoder reconstructs faces in reverse traversal order.
        // We approximate that by reversing the encoder's visited face order.
        let mut faces = Vec::with_capacity(mesh.num_faces());
        for &face_id in self.encoded_faces.iter().rev() {
            let f = mesh.face(face_id);
            faces.push([VertexIndex(f[0].0), VertexIndex(f[1].0), VertexIndex(f[2].0)]);
        }
        // Fallback if for some reason we didn't record all faces.
        if faces.len() != mesh.num_faces() {
            faces.clear();
            for fi in 0..mesh.num_faces() {
                let f = mesh.face(FaceIndex(fi as u32));
                faces.push([VertexIndex(f[0].0), VertexIndex(f[1].0), VertexIndex(f[2].0)]);
            }
        }
        let mut ct = CornerTable::new(0);
        ct.init(&faces);

        // For attribute coding we need the same vertex visitation order on the encoder and
        // decoder. Draco C++ uses a DepthFirstTraverser-based sequencer over the SAME
        // corner table that is used for prediction / decoding order.
        self.point_ids = self.generate_depth_first_point_ids(&ct);
        ct
    }
    fn generate_attribute_traversal(&self, corner_table: &CornerTable) -> (Vec<PointIndex>, Vec<u32>) {
        let num_vertices = corner_table.num_vertices();
        let num_faces = corner_table.num_faces();

        let mut point_ids = Vec::with_capacity(num_vertices);
        let mut data_to_corner_map = Vec::with_capacity(num_vertices);
        let mut visited_vertices = vec![false; num_vertices];
        let mut visited_faces = vec![false; num_faces];

        let visit_vertex = |v: VertexIndex,
                            c: CornerIndex,
                            point_ids: &mut Vec<PointIndex>,
                            data_to_corner_map: &mut Vec<u32>,
                            visited_vertices: &mut [bool]| {
            if v == crate::geometry_indices::INVALID_VERTEX_INDEX {
                return;
            }
            let vi = v.0 as usize;
            if vi >= visited_vertices.len() {
                return;
            }
            if !visited_vertices[vi] {
                visited_vertices[vi] = true;
                point_ids.push(PointIndex(v.0));
                data_to_corner_map.push(c.0);
            }
        };

        let traverse_from_corner = |start_corner: CornerIndex,
                                    point_ids: &mut Vec<PointIndex>,
                                    data_to_corner_map: &mut Vec<u32>,
                                    visited_vertices: &mut Vec<bool>,
                                    visited_faces: &mut Vec<bool>| {
            let start_face = corner_table.face(start_corner);
            if start_face == crate::geometry_indices::INVALID_FACE_INDEX {
                return;
            }
            if visited_faces[start_face.0 as usize] {
                return;
            }

            let mut corner_stack: Vec<CornerIndex> = Vec::new();
            corner_stack.push(start_corner);

            // Pre-visit next and prev vertices for the first face.
            let next_c = corner_table.next(start_corner);
            let prev_c = corner_table.previous(start_corner);
            visit_vertex(corner_table.vertex(next_c), next_c, point_ids, data_to_corner_map, visited_vertices);
            visit_vertex(corner_table.vertex(prev_c), prev_c, point_ids, data_to_corner_map, visited_vertices);

            while let Some(&corner_id0) = corner_stack.last() {
                let face0 = corner_table.face(corner_id0);
                if corner_id0 == INVALID_CORNER_INDEX || face0 == crate::geometry_indices::INVALID_FACE_INDEX || visited_faces[face0.0 as usize] {
                    corner_stack.pop();
                    continue;
                }
                let mut corner_id = corner_id0;
                let mut face_id = face0;
                loop {
                    visited_faces[face_id.0 as usize] = true;
                    let vert_id = corner_table.vertex(corner_id);
                    if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                        break;
                    }
                    if !visited_vertices[vert_id.0 as usize] {
                        let on_boundary = self.is_vertex_on_boundary(corner_table, vert_id);
                        visit_vertex(vert_id, corner_id, point_ids, data_to_corner_map, visited_vertices);
                        if !on_boundary {
                            corner_id = corner_table.right_corner(corner_id);
                            if corner_id == INVALID_CORNER_INDEX {
                                break;
                            }
                            face_id = corner_table.face(corner_id);
                            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                                break;
                            }
                            continue;
                        }
                    }

                    let right_corner_id = corner_table.right_corner(corner_id);
                    let left_corner_id = corner_table.left_corner(corner_id);
                    let right_face_id = if right_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(right_corner_id)
                    };
                    let left_face_id = if left_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(left_corner_id)
                    };

                    let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[right_face_id.0 as usize];
                    let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[left_face_id.0 as usize];

                    if right_visited {
                        if left_visited {
                            corner_stack.pop();
                            break;
                        } else {
                            corner_id = left_corner_id;
                            face_id = left_face_id;
                        }
                    } else {
                        if left_visited {
                            corner_id = right_corner_id;
                            face_id = right_face_id;
                        } else {
                            *corner_stack.last_mut().unwrap() = left_corner_id;
                            corner_stack.push(right_corner_id);
                            break;
                        }
                    }
                }
            }
        };

        // Draco encoder seeds traversal using processed connectivity corners in decoder order.
        let mut corner_order = self.processed_connectivity_corners.clone();
        corner_order.reverse();
        corner_order.extend_from_slice(&self.init_face_connectivity_corners);

        if !corner_order.is_empty() {
            for &c in &corner_order {
                traverse_from_corner(c, &mut point_ids, &mut data_to_corner_map, &mut visited_vertices, &mut visited_faces);
            }
        } else {
            for f in 0..num_faces {
                if visited_faces[f] {
                    continue;
                }
                let first_corner = corner_table.first_corner(FaceIndex(f as u32));
                traverse_from_corner(first_corner, &mut point_ids, &mut data_to_corner_map, &mut visited_vertices, &mut visited_faces);
            }
        }

        // Add any remaining isolated vertices.
        for i in 0..num_vertices {
            if !visited_vertices[i] {
                point_ids.push(PointIndex(i as u32));
                let c = corner_table.left_most_corner(VertexIndex(i as u32));
                data_to_corner_map.push(c.0);
            }
        }

        (point_ids, data_to_corner_map)
    }

    #[allow(dead_code)]
    fn generate_depth_first_point_ids(&self, corner_table: &CornerTable) -> Vec<PointIndex> {
        let num_vertices = corner_table.num_vertices();
        let num_faces = corner_table.num_faces();

        let mut point_ids = Vec::with_capacity(num_vertices);
        let mut visited_vertices = vec![false; num_vertices];
        let mut visited_faces = vec![false; num_faces];

        let visit_vertex = |v: VertexIndex, point_ids: &mut Vec<PointIndex>, visited_vertices: &mut [bool]| {
            if v == crate::geometry_indices::INVALID_VERTEX_INDEX {
                return;
            }
            let vi = v.0 as usize;
            if vi >= visited_vertices.len() {
                return;
            }
            if !visited_vertices[vi] {
                visited_vertices[vi] = true;
                point_ids.push(PointIndex(v.0));
            }
        };

        let traverse_from_corner = |start_corner: CornerIndex,
                                    point_ids: &mut Vec<PointIndex>,
                                    visited_vertices: &mut Vec<bool>,
                                    visited_faces: &mut Vec<bool>| {
            let start_face = corner_table.face(start_corner);
            if start_face == crate::geometry_indices::INVALID_FACE_INDEX {
                return;
            }
            if visited_faces[start_face.0 as usize] {
                return;
            }

            let mut corner_stack: Vec<CornerIndex> = Vec::new();
            corner_stack.push(start_corner);

            // Pre-visit next and prev vertices for the first face.
            let next_c = corner_table.next(start_corner);
            let prev_c = corner_table.previous(start_corner);
            visit_vertex(corner_table.vertex(next_c), point_ids, visited_vertices);
            visit_vertex(corner_table.vertex(prev_c), point_ids, visited_vertices);

            while let Some(&corner_id0) = corner_stack.last() {
                let face0 = corner_table.face(corner_id0);
                if corner_id0 == INVALID_CORNER_INDEX || face0 == crate::geometry_indices::INVALID_FACE_INDEX || visited_faces[face0.0 as usize] {
                    corner_stack.pop();
                    continue;
                }
                let mut corner_id = corner_id0;
                let mut face_id = face0;
                loop {
                    visited_faces[face_id.0 as usize] = true;
                    let vert_id = corner_table.vertex(corner_id);
                    if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                        break;
                    }
                    if !visited_vertices[vert_id.0 as usize] {
                        let on_boundary = self.is_vertex_on_boundary(corner_table, vert_id);
                        visit_vertex(vert_id, point_ids, visited_vertices);
                        if !on_boundary {
                            corner_id = corner_table.right_corner(corner_id);
                            if corner_id == INVALID_CORNER_INDEX {
                                break;
                            }
                            face_id = corner_table.face(corner_id);
                            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                                break;
                            }
                            continue;
                        }
                    }

                    let right_corner_id = corner_table.right_corner(corner_id);
                    let left_corner_id = corner_table.left_corner(corner_id);
                    let right_face_id = if right_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(right_corner_id)
                    };
                    let left_face_id = if left_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(left_corner_id)
                    };

                    let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[right_face_id.0 as usize];
                    let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[left_face_id.0 as usize];

                    if right_visited {
                        if left_visited {
                            corner_stack.pop();
                            break;
                        } else {
                            corner_id = left_corner_id;
                            face_id = left_face_id;
                        }
                    } else {
                        if left_visited {
                            corner_id = right_corner_id;
                            face_id = right_face_id;
                        } else {
                            *corner_stack.last_mut().unwrap() = left_corner_id;
                            corner_stack.push(right_corner_id);
                            break;
                        }
                    }
                }
            }
        };

        for f in 0..num_faces {
            if visited_faces[f] {
                continue;
            }
            let first_corner = corner_table.first_corner(FaceIndex(f as u32));
            traverse_from_corner(first_corner, &mut point_ids, &mut visited_vertices, &mut visited_faces);
        }

        for i in 0..num_vertices {
            if !visited_vertices[i] {
                point_ids.push(PointIndex(i as u32));
            }
        }

        point_ids
    }

    // Legacy helper kept for now (not used by Draco-compatible prediction paths).
    #[allow(dead_code)]
    pub fn generate_data_to_corner_map(&self, corner_table: &CornerTable) -> Vec<u32> {
        let mut vertex_to_corner_map = vec![u32::MAX; corner_table.num_vertices()];
        for fi in 0..corner_table.num_faces() {
            let start_corner = corner_table.first_corner(FaceIndex(fi as u32));
            for i in 0..3 {
                let c = CornerIndex(start_corner.0 + i as u32);
                let v = corner_table.vertex(c);
                if v != crate::geometry_indices::INVALID_VERTEX_INDEX {
                    let v_idx = v.0 as usize;
                    if v_idx < vertex_to_corner_map.len() && vertex_to_corner_map[v_idx] == u32::MAX {
                        vertex_to_corner_map[v_idx] = c.0;
                    }
                }
            }
        }
        for i in 0..corner_table.num_vertices() {
            if vertex_to_corner_map[i] == u32::MAX {
                let c = corner_table.left_most_corner(crate::geometry_indices::VertexIndex(i as u32));
                vertex_to_corner_map[i] = c.0;
            }
        }
        vertex_to_corner_map
    }

    fn encode_traversal_buffer(
        &self,
        mesh: &Mesh,
        out_buffer: &mut EncoderBuffer,
    ) -> Result<(), DracoError> {
        let mut traversal_buffer = EncoderBuffer::new();
        traversal_buffer.set_version(2, 2);

        // Encode traversal symbols as topology bit patterns in reverse order.
        // Draco guarantees <= 3 bits per face.
        traversal_buffer.start_bit_encoding(mesh.num_faces() * 3, true);
        for &sym_id in self.symbols.iter().rev() {
            let (pattern_bits, pattern_value) = match EdgebreakerSymbol::from(sym_id) {
                EdgebreakerSymbol::Center => (1u32, 0u32), // TOPOLOGY_C
                EdgebreakerSymbol::Split => (3u32, 1u32),  // TOPOLOGY_S
                EdgebreakerSymbol::Left => (3u32, 3u32),   // TOPOLOGY_L
                EdgebreakerSymbol::Right => (3u32, 5u32),  // TOPOLOGY_R
                EdgebreakerSymbol::End => (3u32, 7u32),    // TOPOLOGY_E
                EdgebreakerSymbol::Hole => (3u32, 7u32),
            };
            traversal_buffer.encode_least_significant_bits32(pattern_bits, pattern_value);
        }
        traversal_buffer.end_bit_encoding();

        // Encode start face configurations using rANS bit encoder.
        let mut start_face_encoder = RAnsBitEncoder::new();
        start_face_encoder.start_encoding();
        for &is_interior in &self.init_face_configurations {
            start_face_encoder.encode_bit(is_interior);
        }
        start_face_encoder.end_encoding(&mut traversal_buffer);

        out_buffer.encode_data(traversal_buffer.data());
        Ok(())
    }

    fn encode_split_data(&self, out_buffer: &mut EncoderBuffer) -> Result<(), DracoError> {
        let num_events = self.topology_split_event_data.len();
        out_buffer.encode_varint(num_events as u64);
        
        if num_events > 0 {
            // Encode source/split symbol IDs using delta coding.
            let mut last_source_symbol_id: i32 = 0;
            for event in &self.topology_split_event_data {
                // Delta from last source symbol id.
                let delta = (event.source_symbol_id as i32) - last_source_symbol_id;
                out_buffer.encode_varint(delta as u64);

                // Delta from source to split (always positive since source > split).
                let split_delta = (event.source_symbol_id as i32) - (event.split_symbol_id as i32);
                out_buffer.encode_varint(split_delta as u64);

                last_source_symbol_id = event.source_symbol_id as i32;
            }
            // Encode source_edge bits using direct bit encoding (no size prefix), matching C++.
            out_buffer.start_bit_encoding(num_events, false);
            for event in &self.topology_split_event_data {
                out_buffer.encode_least_significant_bits32(1, event.source_edge as u32);
            }
            out_buffer.end_bit_encoding();
        }
        
        Ok(())
    }

    fn is_vertex_on_boundary(&self, corner_table: &CornerTable, v: VertexIndex) -> bool {
        let start_c = corner_table.left_most_corner(v);
        if start_c == INVALID_CORNER_INDEX {
            return false;
        }
        let mut c = start_c;
        loop {
            if corner_table.opposite(c) == INVALID_CORNER_INDEX {
                // Edge opposite to c is (next, prev). Not incident to v.
            }
            // Check edge (prev(c), c) which is opposite(prev(c)).
            // This edge is incident to v.
            if corner_table.opposite(corner_table.previous(c)) == INVALID_CORNER_INDEX {
                return true;
            }
            
            c = corner_table.swing_right(c);
            if c == INVALID_CORNER_INDEX {
                return true;
            }
            if c == start_c {
                break;
            }
        }
        false
    }

    fn is_face_interior(&self, corner_table: &CornerTable, face_id: FaceIndex) -> bool {
        let start_corner = corner_table.first_corner(face_id);
        for i in 0..3 {
            let c = if i == 0 { start_corner } else if i == 1 { corner_table.next(start_corner) } else { corner_table.previous(start_corner) };
            
            if corner_table.opposite(c) == INVALID_CORNER_INDEX {
                return false;
            }
            let v = corner_table.vertex(c);
            if self.is_vertex_on_boundary(corner_table, v) {
                return false;
            }
        }
        true
    }

    fn encode_component(&mut self, corner_table: &CornerTable, start_corner: CornerIndex) -> Result<(), DracoError> {
        let mut corner_traversal_stack: Vec<CornerIndex> = vec![start_corner];

        while !corner_traversal_stack.is_empty() {
            let mut corner_id = *corner_traversal_stack.last().unwrap();
            loop {
                let face_id = corner_table.face(corner_id);
                if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                    // Invalid corner / face; end this branch.
                    corner_traversal_stack.pop();
                    break;
                }
                let fi = face_id.0 as usize;
                if self.visited_faces[fi] {
                    // Already visited; end this branch.
                    corner_traversal_stack.pop();
                    break;
                }

                // Mark current face as visited.
                self.visited_faces[fi] = true;
                self.encoded_faces.push(face_id);
                self.processed_connectivity_corners.push(corner_id);
                self.last_encoded_symbol_id += 1;
                self.face_to_symbol_id[fi] = self.last_encoded_symbol_id as u32;

                // New corner reached.
                let vert_id = corner_table.vertex(corner_id);
                if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                    return Err(DracoError::DracoError("Invalid vertex during Edgebreaker traversal".to_string()));
                }
                let on_boundary = self.is_vertex_on_boundary(corner_table, vert_id);

                // If this is a new vertex and it's not on boundary, emit C and go right.
                if !self.visited_vertices[vert_id.0 as usize] {
                    self.visited_vertices[vert_id.0 as usize] = true;
                    if !on_boundary {
                        self.symbols.push(EdgebreakerSymbol::Center as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_id = corner_table.right_corner(corner_id);
                        *corner_traversal_stack.last_mut().unwrap() = corner_id;
                        continue;
                    }
                }

                // Current vertex already visited or it is on boundary: choose next face.
                let right_corner_id = corner_table.right_corner(corner_id);
                let left_corner_id = corner_table.left_corner(corner_id);
                let right_face_id = corner_table.face(right_corner_id);
                let left_face_id = corner_table.face(left_corner_id);

                let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                    || self.visited_faces[right_face_id.0 as usize];
                let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                    || self.visited_faces[left_face_id.0 as usize];

                if right_visited {
                    if right_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                        self.check_and_store_topology_split_event(
                            face_id.0 as usize,
                            EdgeFaceName::RightFaceEdge,
                            right_face_id.0 as usize,
                        );
                    }
                    if left_visited {
                        if left_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                            self.check_and_store_topology_split_event(
                                face_id.0 as usize,
                                EdgeFaceName::LeftFaceEdge,
                                left_face_id.0 as usize,
                            );
                        }
                        // End reached.
                        self.symbols.push(EdgebreakerSymbol::End as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_traversal_stack.pop();
                        break;
                    } else {
                        // Go to left face.
                        self.symbols.push(EdgebreakerSymbol::Right as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_id = left_corner_id;
                        *corner_traversal_stack.last_mut().unwrap() = corner_id;
                    }
                } else {
                    if left_visited {
                        if left_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                            self.check_and_store_topology_split_event(
                                face_id.0 as usize,
                                EdgeFaceName::LeftFaceEdge,
                                left_face_id.0 as usize,
                            );
                        }
                        // Go to right face.
                        self.symbols.push(EdgebreakerSymbol::Left as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_id = right_corner_id;
                        *corner_traversal_stack.last_mut().unwrap() = corner_id;
                    } else {
                        // Split the traversal.
                        self.symbols.push(EdgebreakerSymbol::Split as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        self.face_to_split_symbol_map
                            .insert(face_id.0 as usize, self.last_encoded_symbol_id);

                        // Process right face first, left face second.
                        *corner_traversal_stack.last_mut().unwrap() = left_corner_id;
                        corner_traversal_stack.push(right_corner_id);
                        break;
                    }
                }
            }
        }

        Ok(())
    }
    
    fn check_and_store_topology_split_event(&mut self, _src_face_id: usize, src_edge: EdgeFaceName, neighbor_face_id: usize) {
        if let Some(&split_symbol_id) = self.face_to_split_symbol_map.get(&neighbor_face_id) {
            let event = TopologySplitEventData {
                split_symbol_id: split_symbol_id as u32,
                source_symbol_id: self.last_encoded_symbol_id as u32,
                source_edge: src_edge,
            };
            self.topology_split_event_data.push(event);
        }
    }
    


    /// Return a reference to the generated symbol stream (for testing/inspection).
    pub fn symbols(&self) -> &[u32] {
        &self.symbols
    }
}
