// Edgebreaker connectivity bitstream layout (C++-compatible).
//
// All integers are Varints unless specified otherwise.
//
// 1) num_vertices (total encoded vertices)
// 2) num_faces
// 3) num_attribute_data (non-position attributes)
// 4) num_encoded_symbols
// 5) num_split_symbols (count of Split symbols)
// 6) topology_split_event_data (see EncodeSplitData below)
// 7) traversal_buffer (as produced by Draco traversal encoder):
//    - bit-encoded traversal symbols (size-prefixed)
//    - start_face_configurations (rANS-bit)
//    - attribute_seam_data (rANS-bit per attribute; not emitted by Rust yet)
//
// Split event encoding (from C++ EncodeSplitData):
//   - num_events (varint)
//   - For each event:
//     - delta(source_symbol_id) from last_source_symbol_id (varint)
//     - delta(source_symbol_id - split_symbol_id) (varint, always positive)
//   - All source_edge bits (1 bit each, direct bit-encoded; only if num_events > 0)

use std::collections::HashMap;
use crate::mesh::Mesh;
use crate::corner_table::CornerTable;
use crate::encoder_buffer::EncoderBuffer;
use crate::status::DracoError;
use crate::geometry_indices::{PointIndex, CornerIndex, FaceIndex, VertexIndex, INVALID_CORNER_INDEX};
use crate::mesh_edgebreaker_shared::{EdgebreakerSymbol, EdgeFaceName, TopologySplitEventData};
use crate::rans_bit_encoder::RAnsBitEncoder;

pub struct MeshEdgebreakerEncoder {
    visited_faces: Vec<bool>,
    visited_vertices: Vec<bool>,
    face_to_symbol_id: Vec<u32>,
    point_ids: Vec<PointIndex>,
    symbols: Vec<u32>,
    topology_split_event_data: Vec<TopologySplitEventData>,
    face_to_split_symbol_map: HashMap<usize, i32>,
    last_encoded_symbol_id: i32,

    // Traversal order for attribute encoding
    processed_connectivity_corners: Vec<CornerIndex>,
    init_face_connectivity_corners: Vec<CornerIndex>,

    // Sequence of vertices as they would be generated by the Decoder.
    // Stored per symbol (in Encoder order).
    symbol_to_encoder_corner: Vec<CornerIndex>,

    // Boundary tracking
    init_face_configurations: Vec<bool>,
    encoded_faces: Vec<FaceIndex>,

    // Hole tracking (for boundary vertices)
    // Maps vertex index to hole id (-1 if not on a hole)
    vertex_hole_id: Vec<i32>,
    // Tracks which holes have been visited during encoding
    visited_holes: Vec<bool>,
}

impl MeshEdgebreakerEncoder {
    pub fn new(num_faces: usize, num_vertices: usize) -> Self {
        Self {
            visited_faces: vec![false; num_faces],
            visited_vertices: vec![false; num_vertices],
            face_to_symbol_id: vec![u32::MAX; num_faces],
            point_ids: Vec::new(),
            symbols: Vec::new(),
            topology_split_event_data: Vec::new(),
            face_to_split_symbol_map: HashMap::new(),
            last_encoded_symbol_id: -1,
            processed_connectivity_corners: Vec::new(),
            init_face_connectivity_corners: Vec::new(),
            symbol_to_encoder_corner: Vec::new(),
            init_face_configurations: Vec::new(),
            encoded_faces: Vec::new(),
            vertex_hole_id: vec![-1; num_vertices],
            visited_holes: Vec::new(),
        }
    }

    /// Find the starting corner for encoding a component.
    /// For boundary faces, returns the corner opposite to a boundary edge.
    /// This matches the C++ FindInitFaceConfiguration logic:
    /// Find the start corner for a face following C++ FindInitFaceConfiguration logic:
    /// - First check each corner for boundary edges (no opposite)
    /// - Also check for boundary vertices (vertex_hole_id != -1) and swing to find boundary edge
    /// - Returns (start_corner, is_interior) - interior is true if no boundary found
    fn find_init_face_configuration(&self, corner_table: &CornerTable, face_id: FaceIndex) -> (CornerIndex, bool) {
        let mut corner_index = corner_table.first_corner(face_id);
        
        for _ in 0..3 {
            // Check for boundary edge
            if corner_table.opposite(corner_index) == INVALID_CORNER_INDEX {
                // Boundary edge found - exterior configuration
                return (corner_index, false);
            }
            
            // Check for boundary vertex
            let vert_id = corner_table.vertex(corner_index);
            if self.vertex_hole_id.get(vert_id.0 as usize).copied().unwrap_or(-1) != -1 {
                // Boundary vertex found. Find the first boundary edge attached to the point.
                let mut right_corner = corner_index;
                while right_corner != INVALID_CORNER_INDEX {
                    corner_index = right_corner;
                    right_corner = corner_table.swing_right(right_corner);
                }
                // corner_index now lies on a boundary edge and its previous corner is
                // guaranteed to be the opposite corner of the boundary edge.
                return (corner_table.previous(corner_index), false);
            }
            
            corner_index = corner_table.next(corner_index);
        }
        
        // Interior configuration: return the current corner (loops back to first after 3 iterations)
        (corner_index, true)
    }

    pub fn encode_connectivity(
        &mut self,
        mesh: &Mesh,
        corner_table: &CornerTable,
        out_buffer: &mut EncoderBuffer,
    ) -> Result<(Vec<PointIndex>, Vec<u32>), DracoError> {
        self.visited_faces = vec![false; mesh.num_faces()];
        self.visited_vertices = vec![false; mesh.num_points()];
        self.symbols.clear();
        self.topology_split_event_data.clear();
        self.face_to_split_symbol_map.clear();
        self.last_encoded_symbol_id = -1;
        self.init_face_configurations.clear();
        self.processed_connectivity_corners.clear();
        self.init_face_connectivity_corners.clear();
        self.symbol_to_encoder_corner.clear();
        self.encoded_faces.clear();
        
        // Reset hole tracking
        self.vertex_hole_id = vec![-1; corner_table.num_vertices()];
        self.visited_holes.clear();

        self.point_ids.clear();

        // Find all holes (boundary loops) in the mesh before encoding
        self.find_holes(corner_table);

        // Traverse the surface starting from each unvisited corner (Draco C++ behavior).
        // For interior components, the init face is not represented by symbols; the
        // decoder reconstructs it from the start-face configuration stream.
        for c_id in 0..corner_table.num_corners() {
            let corner_index = CornerIndex(c_id as u32);
            let face_id = corner_table.face(corner_index);
            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                continue;
            }
            if self.visited_faces[face_id.0 as usize] {
                continue;
            }
            if corner_table.is_degenerated(face_id) {
                continue;
            }

            let (start_corner, interior_config) = self.find_init_face_configuration(corner_table, face_id);
            self.init_face_configurations.push(interior_config);

            if interior_config {
                // Mark all vertices of the init face as visited.
                let v0 = corner_table.vertex(start_corner);
                let v1 = corner_table.vertex(corner_table.next(start_corner));
                let v2 = corner_table.vertex(corner_table.previous(start_corner));
                self.visited_vertices[v0.0 as usize] = true;
                self.visited_vertices[v1.0 as usize] = true;
                self.visited_vertices[v2.0 as usize] = true;

                // Mark the init face as visited (it is reconstructed on decode).
                self.visited_faces[face_id.0 as usize] = true;

                // Store the init-face connectivity corner (processed after regular corners).
                let init_corner = corner_table.next(start_corner);
                self.init_face_connectivity_corners.push(init_corner);

                // Start compressing from the opposite face of the "next" corner.
                let opp_id = corner_table.opposite(init_corner);
                let opp_face_id = corner_table.face(opp_id);
                if opp_face_id != crate::geometry_indices::INVALID_FACE_INDEX
                    && !self.visited_faces[opp_face_id.0 as usize]
                {
                    self.encode_component(corner_table, opp_id)?;
                }
            } else {
                // Boundary configuration: start on the boundary.
                // Mark the init face as visited first to prevent re-processing
                // (Note: encode_component will also mark it when processing the first symbol)
                // First encode the hole that's opposite to the start_corner.
                let next_corner = corner_table.next(start_corner);
                self.encode_hole(corner_table, next_corner, true);
                // Start processing the face containing the start_corner.
                self.encode_component(corner_table, start_corner)?;
            }
        }

        // Write traversal decoder type (Standard = 0)
        out_buffer.encode_u8(0);

        // Write header (C++ format)
        let num_encoded_vertices = corner_table.num_vertices() - corner_table.num_isolated_vertices();
        let num_encoded_faces = corner_table.num_faces() - corner_table.num_degenerated_faces();
        out_buffer.encode_varint(num_encoded_vertices as u64);
        out_buffer.encode_varint(num_encoded_faces as u64);
        out_buffer.encode_u8(0); // num_attribute_data (we don't encode attribute seams yet)

        // Encode number of symbols
        out_buffer.encode_varint(self.symbols.len() as u64);

        // Encode number of split symbols.
        let num_split_symbols = self
            .symbols
            .iter()
            .filter(|&&s| s == EdgebreakerSymbol::Split as u32)
            .count();
        out_buffer.encode_varint(num_split_symbols as u64);

        // Sort split data by source symbol id
        self.topology_split_event_data.sort_by_key(|e| e.source_symbol_id);

        // Encode split event data
        self.encode_split_data(out_buffer)?;

        // Encode traversal buffer (C++ compatible): symbols + start faces.
        self.encode_traversal_buffer(mesh, out_buffer)?;

        // Generate attribute traversal order to match Draco C++:
        // DepthFirstTraverser over the encoder corner table, seeded by the
        // connectivity corners in decoder order.
        let (point_ids, data_to_corner_map) =
            self.generate_attribute_traversal(corner_table);
        self.point_ids = point_ids;

        Ok((self.point_ids.clone(), data_to_corner_map))
    }
    #[allow(dead_code)]    fn generate_point_ids(&mut self, mesh: &Mesh, _encoder_corner_table: &CornerTable) -> CornerTable {
        // For prediction schemes we need a CornerTable that matches the face
        // order produced by the connectivity decoder. The Edgebreaker
        // connectivity decoder reconstructs faces in reverse traversal order.
        // We approximate that by reversing the encoder's visited face order.
        let mut faces = Vec::with_capacity(mesh.num_faces());
        for &face_id in self.encoded_faces.iter().rev() {
            let f = mesh.face(face_id);
            faces.push([VertexIndex(f[0].0), VertexIndex(f[1].0), VertexIndex(f[2].0)]);
        }
        // Fallback if for some reason we didn't record all faces.
        if faces.len() != mesh.num_faces() {
            faces.clear();
            for fi in 0..mesh.num_faces() {
                let f = mesh.face(FaceIndex(fi as u32));
                faces.push([VertexIndex(f[0].0), VertexIndex(f[1].0), VertexIndex(f[2].0)]);
            }
        }
        let mut ct = CornerTable::new(0);
        ct.init(&faces);

        // For attribute coding we need the same vertex visitation order on the encoder and
        // decoder. Draco C++ uses a DepthFirstTraverser-based sequencer over the SAME
        // corner table that is used for prediction / decoding order.
        self.point_ids = self.generate_depth_first_point_ids(&ct);
        ct
    }
    fn generate_attribute_traversal(&self, corner_table: &CornerTable) -> (Vec<PointIndex>, Vec<u32>) {
        let num_vertices = corner_table.num_vertices();
        let num_faces = corner_table.num_faces();

        let mut point_ids = Vec::with_capacity(num_vertices);
        let mut data_to_corner_map = Vec::with_capacity(num_vertices);
        let mut visited_vertices = vec![false; num_vertices];
        let mut visited_faces = vec![false; num_faces];

        let visit_vertex = |v: VertexIndex,
                            c: CornerIndex,
                            point_ids: &mut Vec<PointIndex>,
                            data_to_corner_map: &mut Vec<u32>,
                            visited_vertices: &mut [bool]| {
            if v == crate::geometry_indices::INVALID_VERTEX_INDEX {
                return;
            }
            let vi = v.0 as usize;
            if vi >= visited_vertices.len() {
                return;
            }
            if !visited_vertices[vi] {
                visited_vertices[vi] = true;
                point_ids.push(PointIndex(v.0));
                data_to_corner_map.push(c.0);
            }
        };

        let traverse_from_corner = |start_corner: CornerIndex,
                                    point_ids: &mut Vec<PointIndex>,
                                    data_to_corner_map: &mut Vec<u32>,
                                    visited_vertices: &mut Vec<bool>,
                                    visited_faces: &mut Vec<bool>| {
            let start_face = corner_table.face(start_corner);
            if start_face == crate::geometry_indices::INVALID_FACE_INDEX {
                return;
            }
            if visited_faces[start_face.0 as usize] {
                return;
            }

            let mut corner_stack: Vec<CornerIndex> = Vec::new();
            corner_stack.push(start_corner);

            // Pre-visit next and prev vertices for the first face.
            let next_c = corner_table.next(start_corner);
            let prev_c = corner_table.previous(start_corner);
            visit_vertex(corner_table.vertex(next_c), next_c, point_ids, data_to_corner_map, visited_vertices);
            visit_vertex(corner_table.vertex(prev_c), prev_c, point_ids, data_to_corner_map, visited_vertices);

            while let Some(&corner_id0) = corner_stack.last() {
                let face0 = corner_table.face(corner_id0);
                if corner_id0 == INVALID_CORNER_INDEX || face0 == crate::geometry_indices::INVALID_FACE_INDEX || visited_faces[face0.0 as usize] {
                    corner_stack.pop();
                    continue;
                }
                let mut corner_id = corner_id0;
                let mut face_id = face0;
                loop {
                    visited_faces[face_id.0 as usize] = true;
                    let vert_id = corner_table.vertex(corner_id);
                    if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                        break;
                    }
                    if !visited_vertices[vert_id.0 as usize] {
                        let on_boundary = self.is_vertex_on_boundary(corner_table, vert_id);
                        visit_vertex(vert_id, corner_id, point_ids, data_to_corner_map, visited_vertices);
                        if !on_boundary {
                            corner_id = corner_table.right_corner(corner_id);
                            if corner_id == INVALID_CORNER_INDEX {
                                break;
                            }
                            face_id = corner_table.face(corner_id);
                            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                                break;
                            }
                            continue;
                        }
                    }

                    let right_corner_id = corner_table.right_corner(corner_id);
                    let left_corner_id = corner_table.left_corner(corner_id);
                    let right_face_id = if right_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(right_corner_id)
                    };
                    let left_face_id = if left_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(left_corner_id)
                    };

                    let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[right_face_id.0 as usize];
                    let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[left_face_id.0 as usize];

                    if right_visited {
                        if left_visited {
                            corner_stack.pop();
                            break;
                        } else {
                            corner_id = left_corner_id;
                            face_id = left_face_id;
                        }
                    } else if left_visited {
                        corner_id = right_corner_id;
                        face_id = right_face_id;
                    } else {
                        *corner_stack.last_mut().expect("stack non-empty in traversal") = left_corner_id;
                        corner_stack.push(right_corner_id);
                        break;
                    }
                }
            }
        };

        // Draco encoder seeds traversal using processed connectivity corners in decoder order.
        let mut corner_order = self.processed_connectivity_corners.clone();
        corner_order.reverse();
        corner_order.extend_from_slice(&self.init_face_connectivity_corners);

        if !corner_order.is_empty() {
            for &c in &corner_order {
                traverse_from_corner(c, &mut point_ids, &mut data_to_corner_map, &mut visited_vertices, &mut visited_faces);
            }
        } else {
            for f in 0..num_faces {
                if visited_faces[f] {
                    continue;
                }
                let first_corner = corner_table.first_corner(FaceIndex(f as u32));
                traverse_from_corner(first_corner, &mut point_ids, &mut data_to_corner_map, &mut visited_vertices, &mut visited_faces);
            }
        }

        // Add any remaining isolated vertices.
        for i in 0..num_vertices {
            if !visited_vertices[i] {
                point_ids.push(PointIndex(i as u32));
                let c = corner_table.left_most_corner(VertexIndex(i as u32));
                data_to_corner_map.push(c.0);
            }
        }

        (point_ids, data_to_corner_map)
    }

    #[allow(dead_code)]
    fn generate_depth_first_point_ids(&self, corner_table: &CornerTable) -> Vec<PointIndex> {
        let num_vertices = corner_table.num_vertices();
        let num_faces = corner_table.num_faces();

        let mut point_ids = Vec::with_capacity(num_vertices);
        let mut visited_vertices = vec![false; num_vertices];
        let mut visited_faces = vec![false; num_faces];

        let visit_vertex = |v: VertexIndex, point_ids: &mut Vec<PointIndex>, visited_vertices: &mut [bool]| {
            if v == crate::geometry_indices::INVALID_VERTEX_INDEX {
                return;
            }
            let vi = v.0 as usize;
            if vi >= visited_vertices.len() {
                return;
            }
            if !visited_vertices[vi] {
                visited_vertices[vi] = true;
                point_ids.push(PointIndex(v.0));
            }
        };

        let traverse_from_corner = |start_corner: CornerIndex,
                                    point_ids: &mut Vec<PointIndex>,
                                    visited_vertices: &mut Vec<bool>,
                                    visited_faces: &mut Vec<bool>| {
            let start_face = corner_table.face(start_corner);
            if start_face == crate::geometry_indices::INVALID_FACE_INDEX {
                return;
            }
            if visited_faces[start_face.0 as usize] {
                return;
            }

            let mut corner_stack: Vec<CornerIndex> = Vec::new();
            corner_stack.push(start_corner);

            // Pre-visit next and prev vertices for the first face.
            let next_c = corner_table.next(start_corner);
            let prev_c = corner_table.previous(start_corner);
            visit_vertex(corner_table.vertex(next_c), point_ids, visited_vertices);
            visit_vertex(corner_table.vertex(prev_c), point_ids, visited_vertices);

            while let Some(&corner_id0) = corner_stack.last() {
                let face0 = corner_table.face(corner_id0);
                if corner_id0 == INVALID_CORNER_INDEX || face0 == crate::geometry_indices::INVALID_FACE_INDEX || visited_faces[face0.0 as usize] {
                    corner_stack.pop();
                    continue;
                }
                let mut corner_id = corner_id0;
                let mut face_id = face0;
                loop {
                    visited_faces[face_id.0 as usize] = true;
                    let vert_id = corner_table.vertex(corner_id);
                    if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                        break;
                    }
                    if !visited_vertices[vert_id.0 as usize] {
                        let on_boundary = self.is_vertex_on_boundary(corner_table, vert_id);
                        visit_vertex(vert_id, point_ids, visited_vertices);
                        if !on_boundary {
                            corner_id = corner_table.right_corner(corner_id);
                            if corner_id == INVALID_CORNER_INDEX {
                                break;
                            }
                            face_id = corner_table.face(corner_id);
                            if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                                break;
                            }
                            continue;
                        }
                    }

                    let right_corner_id = corner_table.right_corner(corner_id);
                    let left_corner_id = corner_table.left_corner(corner_id);
                    let right_face_id = if right_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(right_corner_id)
                    };
                    let left_face_id = if left_corner_id == INVALID_CORNER_INDEX {
                        crate::geometry_indices::INVALID_FACE_INDEX
                    } else {
                        corner_table.face(left_corner_id)
                    };

                    let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[right_face_id.0 as usize];
                    let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                        || visited_faces[left_face_id.0 as usize];

                    if right_visited {
                        if left_visited {
                            corner_stack.pop();
                            break;
                        } else {
                            corner_id = left_corner_id;
                            face_id = left_face_id;
                        }
                    } else if left_visited {
                        corner_id = right_corner_id;
                        face_id = right_face_id;
                    } else {
                        *corner_stack.last_mut().expect("stack non-empty in traversal") = left_corner_id;
                        corner_stack.push(right_corner_id);
                        break;
                    }
                }
            }
        };

        for f in 0..num_faces {
            if visited_faces[f] {
                continue;
            }
            let first_corner = corner_table.first_corner(FaceIndex(f as u32));
            traverse_from_corner(first_corner, &mut point_ids, &mut visited_vertices, &mut visited_faces);
        }

        for i in 0..num_vertices {
            if !visited_vertices[i] {
                point_ids.push(PointIndex(i as u32));
            }
        }

        point_ids
    }

    // Legacy helper kept for now (not used by Draco-compatible prediction paths).
    #[allow(dead_code)]
    pub fn generate_data_to_corner_map(&self, corner_table: &CornerTable) -> Vec<u32> {
        let mut vertex_to_corner_map = vec![u32::MAX; corner_table.num_vertices()];
        for fi in 0..corner_table.num_faces() {
            let start_corner = corner_table.first_corner(FaceIndex(fi as u32));
            for i in 0..3 {
                let c = CornerIndex(start_corner.0 + i as u32);
                let v = corner_table.vertex(c);
                if v != crate::geometry_indices::INVALID_VERTEX_INDEX {
                    let v_idx = v.0 as usize;
                    if v_idx < vertex_to_corner_map.len() && vertex_to_corner_map[v_idx] == u32::MAX {
                        vertex_to_corner_map[v_idx] = c.0;
                    }
                }
            }
        }
        for i in 0..corner_table.num_vertices() {
            if vertex_to_corner_map[i] == u32::MAX {
                let c = corner_table.left_most_corner(crate::geometry_indices::VertexIndex(i as u32));
                vertex_to_corner_map[i] = c.0;
            }
        }
        vertex_to_corner_map
    }

    fn encode_traversal_buffer(
        &self,
        mesh: &Mesh,
        out_buffer: &mut EncoderBuffer,
    ) -> Result<(), DracoError> {
        let mut traversal_buffer = EncoderBuffer::new();
        traversal_buffer.set_version(2, 2);

        // Encode traversal symbols as topology bit patterns in reverse order.
        // Draco guarantees <= 3 bits per face.
        traversal_buffer.start_bit_encoding(mesh.num_faces() * 3, true);
        for &sym_id in self.symbols.iter().rev() {
            let (pattern_bits, pattern_value) = match EdgebreakerSymbol::from(sym_id) {
                EdgebreakerSymbol::Center => (1u32, 0u32), // TOPOLOGY_C
                EdgebreakerSymbol::Split => (3u32, 1u32),  // TOPOLOGY_S
                EdgebreakerSymbol::Left => (3u32, 3u32),   // TOPOLOGY_L
                EdgebreakerSymbol::Right => (3u32, 5u32),  // TOPOLOGY_R
                EdgebreakerSymbol::End => (3u32, 7u32),    // TOPOLOGY_E
                EdgebreakerSymbol::Hole => (3u32, 7u32),
            };
            traversal_buffer.encode_least_significant_bits32(pattern_bits, pattern_value);
        }
        traversal_buffer.end_bit_encoding();

        // Encode start face configurations using rANS bit encoder.
        let mut start_face_encoder = RAnsBitEncoder::new();
        start_face_encoder.start_encoding();
        for &is_interior in &self.init_face_configurations {
            start_face_encoder.encode_bit(is_interior);
        }
        start_face_encoder.end_encoding(&mut traversal_buffer);

        out_buffer.encode_data(traversal_buffer.data());
        Ok(())
    }

    fn encode_split_data(&self, out_buffer: &mut EncoderBuffer) -> Result<(), DracoError> {
        let num_events = self.topology_split_event_data.len();
        out_buffer.encode_varint(num_events as u64);
        
        if num_events > 0 {
            // Encode source/split symbol IDs using delta coding.
            let mut last_source_symbol_id: i32 = 0;
            for event in &self.topology_split_event_data {
                // Delta from last source symbol id.
                let delta = (event.source_symbol_id as i32) - last_source_symbol_id;
                out_buffer.encode_varint(delta as u64);

                // Delta from source to split (always positive since source > split).
                let split_delta = (event.source_symbol_id as i32) - (event.split_symbol_id as i32);
                out_buffer.encode_varint(split_delta as u64);

                last_source_symbol_id = event.source_symbol_id as i32;
            }
            // Encode source_edge bits using direct bit encoding (no size prefix), matching C++.
            out_buffer.start_bit_encoding(num_events, false);
            for event in &self.topology_split_event_data {
                out_buffer.encode_least_significant_bits32(1, event.source_edge as u32);
            }
            out_buffer.end_bit_encoding();
        }
        
        Ok(())
    }

    fn is_vertex_on_boundary(&self, corner_table: &CornerTable, v: VertexIndex) -> bool {
        let start_c = corner_table.left_most_corner(v);
        if start_c == INVALID_CORNER_INDEX {
            return false;
        }
        let mut c = start_c;
        loop {
            if corner_table.opposite(c) == INVALID_CORNER_INDEX {
                // Edge opposite to c is (next, prev). Not incident to v.
            }
            // Check edge (prev(c), c) which is opposite(prev(c)).
            // This edge is incident to v.
            if corner_table.opposite(corner_table.previous(c)) == INVALID_CORNER_INDEX {
                return true;
            }
            
            c = corner_table.swing_right(c);
            if c == INVALID_CORNER_INDEX {
                return true;
            }
            if c == start_c {
                break;
            }
        }
        false
    }

    /// Finds all holes (boundary loops) in the mesh and assigns each boundary vertex
    /// to its hole ID. This matches the C++ FindHoles() function.
    fn find_holes(&mut self, corner_table: &CornerTable) {
        let num_corners = corner_table.num_corners();
        
        // Go over all corners and detect non-visited open boundaries
        for i in 0..num_corners {
            let corner_i = CornerIndex(i as u32);
            
            // Skip degenerated faces
            let face = corner_table.face(corner_i);
            if face == crate::geometry_indices::INVALID_FACE_INDEX || corner_table.is_degenerated(face) {
                continue;
            }
            
            // Check if this corner is opposite to a boundary edge
            if corner_table.opposite(corner_i) == INVALID_CORNER_INDEX {
                // No opposite corner means no opposite face, so the opposite edge
                // of the corner is an open boundary.
                // Check whether we have already traversed the boundary.
                let boundary_vert_id = corner_table.vertex(corner_table.next(corner_i));
                if boundary_vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                    continue;
                }
                let bv = boundary_vert_id.0 as usize;
                if bv >= self.vertex_hole_id.len() {
                    continue;
                }
                if self.vertex_hole_id[bv] != -1 {
                    // Already assigned to a hole
                    continue;
                }
                
                // New open boundary found - traverse along it and mark all vertices
                let boundary_id = self.visited_holes.len() as i32;
                self.visited_holes.push(false);
                
                let mut corner_id = corner_i;
                let mut current_boundary_vert = boundary_vert_id;
                
                // Safety limit for boundary traversal
                let max_verts = corner_table.num_vertices();
                let mut vert_count = 0;
                
                while self.vertex_hole_id[current_boundary_vert.0 as usize] == -1 {
                    vert_count += 1;
                    if vert_count > max_verts {
                        break; // Safety exit
                    }
                    
                    // Mark the vertex on the open boundary
                    self.vertex_hole_id[current_boundary_vert.0 as usize] = boundary_id;
                    
                    // Move to next corner on the boundary
                    corner_id = corner_table.next(corner_id);
                    
                    // Look for the next attached open boundary edge (with safety limit)
                    let mut inner_iter = 0;
                    while corner_table.opposite(corner_id) != INVALID_CORNER_INDEX {
                        corner_id = corner_table.opposite(corner_id);
                        corner_id = corner_table.next(corner_id);
                        inner_iter += 1;
                        if inner_iter > max_verts {
                            break;
                        }
                    }
                    
                    // Get the next vertex on the hole
                    current_boundary_vert = corner_table.vertex(corner_table.next(corner_id));
                    if current_boundary_vert == crate::geometry_indices::INVALID_VERTEX_INDEX {
                        break;
                    }
                    if (current_boundary_vert.0 as usize) >= self.vertex_hole_id.len() {
                        break;
                    }
                }
            }
        }
    }

    /// Encodes all vertices of a hole starting at start_corner_id.
    /// The vertex associated with the first corner is encoded only if encode_first_vertex is true.
    /// Returns the number of encoded hole vertices.
    /// This matches the C++ EncodeHole() function.
    fn encode_hole(&mut self, corner_table: &CornerTable, start_corner_id: CornerIndex, encode_first_vertex: bool) -> i32 {
        // We know that the start corner lies on a hole but we first need to find the
        // boundary edge going from that vertex. It is the first edge in CW direction.
        let mut corner_id = start_corner_id;
        corner_id = corner_table.previous(corner_id);
        
        // Add safety limit to prevent infinite loops
        let max_iters = corner_table.num_corners();
        let mut iter_count = 0;
        while corner_table.opposite(corner_id) != INVALID_CORNER_INDEX {
            corner_id = corner_table.opposite(corner_id);
            corner_id = corner_table.next(corner_id);
            iter_count += 1;
            if iter_count > max_iters {
                // Safety exit - we're stuck in a loop
                return 0;
            }
        }
        
        let start_vertex_id = corner_table.vertex(start_corner_id);
        if start_vertex_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
            return 0;
        }
        
        let mut num_encoded_hole_verts = 0;
        if encode_first_vertex {
            let sv = start_vertex_id.0 as usize;
            if sv < self.visited_vertices.len() {
                self.visited_vertices[sv] = true;
            }
            num_encoded_hole_verts += 1;
        }
        
        // Mark the hole as visited
        let start_vid = start_vertex_id.0 as usize;
        if start_vid < self.vertex_hole_id.len() {
            let hole_id = self.vertex_hole_id[start_vid];
            if hole_id >= 0 && (hole_id as usize) < self.visited_holes.len() {
                self.visited_holes[hole_id as usize] = true;
            }
        }
        
        // corner_id is now opposite to the boundary edge.
        // Get the start vertex of the edge and use it as a reference.
        let _start_vert_id = corner_table.vertex(corner_table.next(corner_id));
        
        // Get the end vertex of the edge.
        let mut act_vertex_id = corner_table.vertex(corner_table.previous(corner_id));
        
        // Safety counter for the main loop
        iter_count = 0;
        while act_vertex_id != start_vertex_id {
            if act_vertex_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                break;
            }
            
            iter_count += 1;
            if iter_count > max_iters {
                // Safety exit
                break;
            }
            
            // Mark the vertex as visited
            let av = act_vertex_id.0 as usize;
            if av < self.visited_vertices.len() {
                self.visited_vertices[av] = true;
            }
            num_encoded_hole_verts += 1;
            
            corner_id = corner_table.next(corner_id);
            
            // Look for the next attached open boundary edge (with safety limit)
            let mut inner_iter = 0;
            while corner_table.opposite(corner_id) != INVALID_CORNER_INDEX {
                corner_id = corner_table.opposite(corner_id);
                corner_id = corner_table.next(corner_id);
                inner_iter += 1;
                if inner_iter > max_iters {
                    break;
                }
            }
            
            act_vertex_id = corner_table.vertex(corner_table.previous(corner_id));
        }
        
        num_encoded_hole_verts
    }

    fn encode_component(&mut self, corner_table: &CornerTable, start_corner: CornerIndex) -> Result<(), DracoError> {
        let mut corner_traversal_stack: Vec<CornerIndex> = vec![start_corner];

        while !corner_traversal_stack.is_empty() {
            let mut corner_id = *corner_traversal_stack.last().expect("loop ensures non-empty");
            loop {
                let face_id = corner_table.face(corner_id);
                if face_id == crate::geometry_indices::INVALID_FACE_INDEX {
                    // Invalid corner / face; end this branch.
                    corner_traversal_stack.pop();
                    break;
                }
                let fi = face_id.0 as usize;
                if self.visited_faces[fi] {
                    // Already visited; end this branch.
                    corner_traversal_stack.pop();
                    break;
                }

                // Mark current face as visited.
                self.visited_faces[fi] = true;
                self.encoded_faces.push(face_id);
                self.processed_connectivity_corners.push(corner_id);
                self.last_encoded_symbol_id += 1;
                self.face_to_symbol_id[fi] = self.last_encoded_symbol_id as u32;

                // New corner reached.
                let vert_id = corner_table.vertex(corner_id);
                if vert_id == crate::geometry_indices::INVALID_VERTEX_INDEX {
                    return Err(DracoError::DracoError("Invalid vertex during Edgebreaker traversal".to_string()));
                }
                // Check if vertex is on a boundary using the precomputed hole IDs
                let on_boundary = self.vertex_hole_id.get(vert_id.0 as usize).copied().unwrap_or(-1) != -1;

                // If this is a new vertex and it's not on boundary, emit C and go right.
                if !self.visited_vertices[vert_id.0 as usize] {
                    self.visited_vertices[vert_id.0 as usize] = true;
                    if !on_boundary {
                        self.symbols.push(EdgebreakerSymbol::Center as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_id = corner_table.right_corner(corner_id);
                        *corner_traversal_stack.last_mut().expect("stack non-empty") = corner_id;
                        continue;
                    }
                }

                // Current vertex already visited or it is on boundary: choose next face.
                let right_corner_id = corner_table.right_corner(corner_id);
                let left_corner_id = corner_table.left_corner(corner_id);
                let right_face_id = corner_table.face(right_corner_id);
                let left_face_id = corner_table.face(left_corner_id);

                let right_visited = right_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                    || self.visited_faces[right_face_id.0 as usize];
                let left_visited = left_face_id == crate::geometry_indices::INVALID_FACE_INDEX
                    || self.visited_faces[left_face_id.0 as usize];

                if right_visited {
                    if right_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                        self.check_and_store_topology_split_event(
                            face_id.0 as usize,
                            EdgeFaceName::RightFaceEdge,
                            right_face_id.0 as usize,
                        );
                    }
                    if left_visited {
                        if left_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                            self.check_and_store_topology_split_event(
                                face_id.0 as usize,
                                EdgeFaceName::LeftFaceEdge,
                                left_face_id.0 as usize,
                            );
                        }
                        // End reached.
                        self.symbols.push(EdgebreakerSymbol::End as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_traversal_stack.pop();
                        break;
                    } else {
                        // Go to left face.
                        self.symbols.push(EdgebreakerSymbol::Right as u32);
                        self.symbol_to_encoder_corner.push(corner_id);
                        corner_id = left_corner_id;
                        *corner_traversal_stack.last_mut().expect("stack non-empty") = corner_id;
                    }
                } else if left_visited {
                    if left_face_id != crate::geometry_indices::INVALID_FACE_INDEX {
                        self.check_and_store_topology_split_event(
                            face_id.0 as usize,
                            EdgeFaceName::LeftFaceEdge,
                            left_face_id.0 as usize,
                        );
                    }
                    // Go to right face.
                    self.symbols.push(EdgebreakerSymbol::Left as u32);
                    self.symbol_to_encoder_corner.push(corner_id);
                    corner_id = right_corner_id;
                    *corner_traversal_stack.last_mut().expect("stack non-empty") = corner_id;
                } else {
                    // Split the traversal.
                    self.symbols.push(EdgebreakerSymbol::Split as u32);
                    self.symbol_to_encoder_corner.push(corner_id);
                    
                    // If the tip vertex is on a hole boundary and the hole hasn't been
                    // visited yet, we need to encode it. This marks all vertices on
                    // the hole as visited, which matches C++ EncodeHole behavior.
                    if on_boundary {
                        let hole_id = self.vertex_hole_id.get(vert_id.0 as usize).copied().unwrap_or(-1);
                        if hole_id >= 0 && (hole_id as usize) < self.visited_holes.len()
                            && !self.visited_holes[hole_id as usize] {
                                self.encode_hole(corner_table, corner_id, false);
                            }
                    }
                    
                    self.face_to_split_symbol_map
                        .insert(face_id.0 as usize, self.last_encoded_symbol_id);

                    // Process right face first, left face second.
                    *corner_traversal_stack.last_mut().expect("stack non-empty") = left_corner_id;
                    corner_traversal_stack.push(right_corner_id);
                    break;
                }
            }
        }

        Ok(())
    }
    
    fn check_and_store_topology_split_event(&mut self, _src_face_id: usize, src_edge: EdgeFaceName, neighbor_face_id: usize) {
        if let Some(&split_symbol_id) = self.face_to_split_symbol_map.get(&neighbor_face_id) {
            let event = TopologySplitEventData {
                split_symbol_id: split_symbol_id as u32,
                source_symbol_id: self.last_encoded_symbol_id as u32,
                source_edge: src_edge,
            };
            self.topology_split_event_data.push(event);
        }
    }
    


    /// Return a reference to the generated symbol stream (for testing/inspection).
    pub fn symbols(&self) -> &[u32] {
        &self.symbols
    }
}
