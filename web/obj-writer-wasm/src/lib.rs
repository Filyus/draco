//! OBJ Writer WASM module.
//!
//! Provides OBJ file generation functionality for web applications.

use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};

/// Input mesh data from JavaScript.
#[derive(Serialize, Deserialize)]
pub struct MeshInput {
    /// Vertex positions as flat array [x0, y0, z0, x1, y1, z1, ...]
    pub positions: Vec<f32>,
    /// Face indices as flat array (triangles)
    pub indices: Vec<u32>,
    /// Vertex normals (optional)
    pub normals: Option<Vec<f32>>,
    /// Texture coordinates (optional)
    pub uvs: Option<Vec<f32>>,
    /// Mesh name (optional)
    pub name: Option<String>,
}

/// Export options.
#[derive(Serialize, Deserialize, Default)]
pub struct ExportOptions {
    /// Include normals in output
    pub include_normals: Option<bool>,
    /// Include UVs in output
    pub include_uvs: Option<bool>,
    /// Decimal precision for coordinates
    pub precision: Option<u32>,
}

/// Export result.
#[derive(Serialize, Deserialize)]
pub struct ExportResult {
    pub success: bool,
    pub data: Option<String>,
    pub error: Option<String>,
}

/// Initialize panic hook for better error messages in browser console.
#[wasm_bindgen(start)]
pub fn init() {
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

/// Get the version of this WASM module.
#[wasm_bindgen]
pub fn version() -> String {
    "0.1.0".to_string()
}

/// Get the module name.
#[wasm_bindgen]
pub fn module_name() -> String {
    "OBJ Writer".to_string()
}

/// Get supported file extensions.
#[wasm_bindgen]
pub fn supported_extensions() -> Vec<String> {
    vec!["obj".to_string()]
}

/// Create OBJ content from mesh data.
#[wasm_bindgen]
pub fn create_obj(mesh_js: JsValue, options_js: JsValue) -> JsValue {
    let mesh: MeshInput = match serde_wasm_bindgen::from_value(mesh_js) {
        Ok(m) => m,
        Err(e) => {
            let result = ExportResult {
                success: false,
                data: None,
                error: Some(format!("Invalid mesh data: {}", e)),
            };
            return serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL);
        }
    };

    let options: ExportOptions = serde_wasm_bindgen::from_value(options_js).unwrap_or_default();
    let result = create_obj_internal(&mesh, &options);
    serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL)
}

/// Create OBJ content from multiple meshes.
#[wasm_bindgen]
pub fn create_obj_multi(meshes_js: JsValue, options_js: JsValue) -> JsValue {
    let meshes: Vec<MeshInput> = match serde_wasm_bindgen::from_value(meshes_js) {
        Ok(m) => m,
        Err(e) => {
            let result = ExportResult {
                success: false,
                data: None,
                error: Some(format!("Invalid mesh data: {}", e)),
            };
            return serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL);
        }
    };

    let options: ExportOptions = serde_wasm_bindgen::from_value(options_js).unwrap_or_default();
    let result = create_obj_multi_internal(&meshes, &options);
    serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL)
}

fn create_obj_internal(mesh: &MeshInput, options: &ExportOptions) -> ExportResult {
    create_obj_multi_internal(&[mesh.clone()], options)
}

fn create_obj_multi_internal(meshes: &[MeshInput], options: &ExportOptions) -> ExportResult {
    let precision = options.precision.unwrap_or(6) as usize;
    let include_normals = options.include_normals.unwrap_or(true);
    let include_uvs = options.include_uvs.unwrap_or(true);

    let mut output = String::new();
    output.push_str("# OBJ file generated by draco-io WASM\n");
    output.push_str(&format!("# Meshes: {}\n\n", meshes.len()));

    let mut vertex_offset: u32 = 0;
    let mut normal_offset: u32 = 0;
    let mut uv_offset: u32 = 0;

    for (mesh_idx, mesh) in meshes.iter().enumerate() {
        // Write object/group name
        let default_name = format!("mesh_{}", mesh_idx);
        let name = mesh.name.as_deref().unwrap_or(&default_name);
        output.push_str(&format!("o {}\n", name));

        // Write vertices
        let vertex_count = mesh.positions.len() / 3;
        for i in 0..vertex_count {
            let x = mesh.positions[i * 3];
            let y = mesh.positions[i * 3 + 1];
            let z = mesh.positions[i * 3 + 2];
            output.push_str(&format!("v {:.*} {:.*} {:.*}\n", precision, x, precision, y, precision, z));
        }

        // Write normals
        let mut has_normals = false;
        if include_normals {
            if let Some(ref normals) = mesh.normals {
                if !normals.is_empty() {
                    has_normals = true;
                    let normal_count = normals.len() / 3;
                    for i in 0..normal_count {
                        let nx = normals[i * 3];
                        let ny = normals[i * 3 + 1];
                        let nz = normals[i * 3 + 2];
                        output.push_str(&format!("vn {:.*} {:.*} {:.*}\n", precision, nx, precision, ny, precision, nz));
                    }
                }
            }
        }

        // Write UVs
        let mut has_uvs = false;
        if include_uvs {
            if let Some(ref uvs) = mesh.uvs {
                if !uvs.is_empty() {
                    has_uvs = true;
                    let uv_count = uvs.len() / 2;
                    for i in 0..uv_count {
                        let u = uvs[i * 2];
                        let v = uvs[i * 2 + 1];
                        output.push_str(&format!("vt {:.*} {:.*}\n", precision, u, precision, v));
                    }
                }
            }
        }

        // Write faces
        let face_count = mesh.indices.len() / 3;
        for i in 0..face_count {
            let i0 = mesh.indices[i * 3] + vertex_offset + 1;
            let i1 = mesh.indices[i * 3 + 1] + vertex_offset + 1;
            let i2 = mesh.indices[i * 3 + 2] + vertex_offset + 1;

            if has_normals && has_uvs {
                // f v/vt/vn
                let n0 = mesh.indices[i * 3] + normal_offset + 1;
                let n1 = mesh.indices[i * 3 + 1] + normal_offset + 1;
                let n2 = mesh.indices[i * 3 + 2] + normal_offset + 1;
                let t0 = mesh.indices[i * 3] + uv_offset + 1;
                let t1 = mesh.indices[i * 3 + 1] + uv_offset + 1;
                let t2 = mesh.indices[i * 3 + 2] + uv_offset + 1;
                output.push_str(&format!("f {}/{}/{} {}/{}/{} {}/{}/{}\n", i0, t0, n0, i1, t1, n1, i2, t2, n2));
            } else if has_normals {
                // f v//vn
                let n0 = mesh.indices[i * 3] + normal_offset + 1;
                let n1 = mesh.indices[i * 3 + 1] + normal_offset + 1;
                let n2 = mesh.indices[i * 3 + 2] + normal_offset + 1;
                output.push_str(&format!("f {}//{} {}//{} {}//{}\n", i0, n0, i1, n1, i2, n2));
            } else if has_uvs {
                // f v/vt
                let t0 = mesh.indices[i * 3] + uv_offset + 1;
                let t1 = mesh.indices[i * 3 + 1] + uv_offset + 1;
                let t2 = mesh.indices[i * 3 + 2] + uv_offset + 1;
                output.push_str(&format!("f {}/{} {}/{} {}/{}\n", i0, t0, i1, t1, i2, t2));
            } else {
                // f v
                output.push_str(&format!("f {} {} {}\n", i0, i1, i2));
            }
        }

        // Update offsets for next mesh
        vertex_offset += vertex_count as u32;
        if has_normals {
            if let Some(ref normals) = mesh.normals {
                normal_offset += (normals.len() / 3) as u32;
            }
        }
        if has_uvs {
            if let Some(ref uvs) = mesh.uvs {
                uv_offset += (uvs.len() / 2) as u32;
            }
        }

        output.push('\n');
    }

    ExportResult {
        success: true,
        data: Some(output),
        error: None,
    }
}

impl Clone for MeshInput {
    fn clone(&self) -> Self {
        Self {
            positions: self.positions.clone(),
            indices: self.indices.clone(),
            normals: self.normals.clone(),
            uvs: self.uvs.clone(),
            name: self.name.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_simple_obj() {
        let mesh = MeshInput {
            positions: vec![0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 1.0, 0.0],
            indices: vec![0, 1, 2],
            normals: None,
            uvs: None,
            name: Some("triangle".to_string()),
        };

        let result = create_obj_internal(&mesh, &ExportOptions::default());
        assert!(result.success);
        assert!(result.data.is_some());
        let data = result.data.unwrap();
        assert!(data.contains("v 0."));
        assert!(data.contains("f 1 2 3"));
    }
}
