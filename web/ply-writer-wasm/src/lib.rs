//! PLY Writer WASM module.
//!
//! Provides PLY file generation functionality for web applications.

use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};

/// Input mesh data from JavaScript.
#[derive(Serialize, Deserialize, Clone)]
pub struct MeshInput {
    /// Vertex positions as flat array [x0, y0, z0, x1, y1, z1, ...]
    pub positions: Vec<f32>,
    /// Face indices as flat array (triangles)
    pub indices: Vec<u32>,
    /// Vertex normals (optional)
    pub normals: Option<Vec<f32>>,
    /// Vertex colors as [r, g, b, a, ...] 0-255 (optional)
    pub colors: Option<Vec<u8>>,
}

/// Export options.
#[derive(Serialize, Deserialize, Default)]
pub struct ExportOptions {
    /// Include normals in output
    pub include_normals: Option<bool>,
    /// Include colors in output
    pub include_colors: Option<bool>,
    /// Decimal precision for coordinates
    pub precision: Option<u32>,
    /// Output format: "ascii" or "binary_little_endian"
    pub format: Option<String>,
}

/// Export result.
#[derive(Serialize, Deserialize)]
pub struct ExportResult {
    pub success: bool,
    pub data: Option<String>,
    pub binary_data: Option<Vec<u8>>,
    pub error: Option<String>,
}

/// Initialize panic hook for better error messages in browser console.
#[wasm_bindgen(start)]
pub fn init() {
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

/// Get the version of this WASM module.
#[wasm_bindgen]
pub fn version() -> String {
    "0.1.0".to_string()
}

/// Get the module name.
#[wasm_bindgen]
pub fn module_name() -> String {
    "PLY Writer".to_string()
}

/// Get supported file extensions.
#[wasm_bindgen]
pub fn supported_extensions() -> Vec<String> {
    vec!["ply".to_string()]
}

/// Create PLY content from mesh data.
#[wasm_bindgen]
pub fn create_ply(mesh_js: JsValue, options_js: JsValue) -> JsValue {
    let mesh: MeshInput = match serde_wasm_bindgen::from_value(mesh_js) {
        Ok(m) => m,
        Err(e) => {
            let result = ExportResult {
                success: false,
                data: None,
                binary_data: None,
                error: Some(format!("Invalid mesh data: {}", e)),
            };
            return serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL);
        }
    };

    let options: ExportOptions = serde_wasm_bindgen::from_value(options_js).unwrap_or_default();
    let result = create_ply_internal(&mesh, &options);
    serde_wasm_bindgen::to_value(&result).unwrap_or(JsValue::NULL)
}

fn create_ply_internal(mesh: &MeshInput, options: &ExportOptions) -> ExportResult {
    let precision = options.precision.unwrap_or(6) as usize;
    let include_normals = options.include_normals.unwrap_or(true);
    let include_colors = options.include_colors.unwrap_or(true);
    let format = options.format.as_deref().unwrap_or("ascii");

    if format != "ascii" {
        return ExportResult {
            success: false,
            data: None,
            binary_data: None,
            error: Some("Binary PLY export not yet implemented".to_string()),
        };
    }

    let vertex_count = mesh.positions.len() / 3;
    let face_count = mesh.indices.len() / 3;

    let has_normals = include_normals && mesh.normals.as_ref().map_or(false, |n| !n.is_empty());
    let has_colors = include_colors && mesh.colors.as_ref().map_or(false, |c| !c.is_empty());

    let mut output = String::new();

    // Header
    output.push_str("ply\n");
    output.push_str("format ascii 1.0\n");
    output.push_str("comment Generated by draco-io WASM\n");
    output.push_str(&format!("element vertex {}\n", vertex_count));
    output.push_str("property float x\n");
    output.push_str("property float y\n");
    output.push_str("property float z\n");

    if has_normals {
        output.push_str("property float nx\n");
        output.push_str("property float ny\n");
        output.push_str("property float nz\n");
    }

    if has_colors {
        output.push_str("property uchar red\n");
        output.push_str("property uchar green\n");
        output.push_str("property uchar blue\n");
        output.push_str("property uchar alpha\n");
    }

    output.push_str(&format!("element face {}\n", face_count));
    output.push_str("property list uchar int vertex_indices\n");
    output.push_str("end_header\n");

    // Vertices
    for i in 0..vertex_count {
        let x = mesh.positions[i * 3];
        let y = mesh.positions[i * 3 + 1];
        let z = mesh.positions[i * 3 + 2];

        let mut line = format!("{:.*} {:.*} {:.*}", precision, x, precision, y, precision, z);

        if has_normals {
            if let Some(ref normals) = mesh.normals {
                let nx = normals.get(i * 3).copied().unwrap_or(0.0);
                let ny = normals.get(i * 3 + 1).copied().unwrap_or(0.0);
                let nz = normals.get(i * 3 + 2).copied().unwrap_or(0.0);
                line.push_str(&format!(" {:.*} {:.*} {:.*}", precision, nx, precision, ny, precision, nz));
            }
        }

        if has_colors {
            if let Some(ref colors) = mesh.colors {
                let r = colors.get(i * 4).copied().unwrap_or(255);
                let g = colors.get(i * 4 + 1).copied().unwrap_or(255);
                let b = colors.get(i * 4 + 2).copied().unwrap_or(255);
                let a = colors.get(i * 4 + 3).copied().unwrap_or(255);
                line.push_str(&format!(" {} {} {} {}", r, g, b, a));
            }
        }

        output.push_str(&line);
        output.push('\n');
    }

    // Faces
    for i in 0..face_count {
        let i0 = mesh.indices[i * 3];
        let i1 = mesh.indices[i * 3 + 1];
        let i2 = mesh.indices[i * 3 + 2];
        output.push_str(&format!("3 {} {} {}\n", i0, i1, i2));
    }

    ExportResult {
        success: true,
        data: Some(output),
        binary_data: None,
        error: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_simple_ply() {
        let mesh = MeshInput {
            positions: vec![0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 1.0, 0.0],
            indices: vec![0, 1, 2],
            normals: None,
            colors: None,
        };

        let result = create_ply_internal(&mesh, &ExportOptions::default());
        assert!(result.success);
        assert!(result.data.is_some());
        let data = result.data.unwrap();
        assert!(data.contains("ply"));
        assert!(data.contains("element vertex 3"));
        assert!(data.contains("element face 1"));
    }
}
